# 批处理系统

---

# 特权级机制

两个主要的限制：

* 应用程序不能访问任意的地址空间
* 应用程序不能执行某些可能破坏计算机系统的指令(重点)

此外，我们还需要构建交互手段。
实现方法：处理器设置两个不同安全等级的执行环境：1. 用户态特权级的执行环境；2. 内核态特权级的执行环境。特权级指令子集中的指令只能在内核态特权级的执行环境中执行。
使用ecall和eret来执行。

## RISC-V特权级架构

S模式：操作系统内核代码，其基于SEE运行。
U模式：应用程序
M模式：**监督模式执行环境**（SEE,Supervisor Execution Enviroment），比如OS运行前负责加载OS的Bootloader-RustSBI
RISC-V架构中，只有M模式是必须实现的，剩下的都可以进行调整。

* 简单的嵌入式应用只需要实现M模式
* 带有一定保护能力的嵌入式系统需要实现M/U模式
* 复杂的多人物系统需要实现M/S/U模式
* 目前H模式在24年4月已经完成制定。

执行环境还负责了对上层软件的执行进行监控管理。即：当上层软件执行的时候出现了一些异常或特殊情况，导致需要用到执行环境中提供的功能，因此需要暂停上层软件的执行，转而运行执行环境的代码。这个过程往往而**不一定**伴随CPU的**特权级切换**。这种与常规控制流不同的叫**异常控制流**，称为**异常（Exception）**，是RISC-V中的Trap之一。

**断点（breakpoint）**和**执行环境调用（Enviroment Call）**两种异常（又叫做*陷入*或*trap*指令）可以通过执行指令触发的。

* `ebreak`指令执行后出发断点异常
* `ecall`指令执行后会随特权级触发异常

`ecall`是一种特殊的*trap*指令，两个相邻的特权级之间的接口就是基于这种陷入机制实现的。M模式软件SEE和S模式内核之间的接口是**监督模式二进制接口（Supervisor Binary Interface，SBI）**，内核和U模式之间的叫**应用程序二进制接口（Application Binary Interface，ABI）**，也叫**系统调用（Syscall）**

这些二进制接口的调用方式是**陷入异常控制流**，切换特权级。

## RISC-V的特权指令

与特权无关的一般指令和通用寄存器`x0～x31`可以在任何特权级执行。存在每个特权级的特殊指令和CSR。

# 实现应用程序

应用程序的设计要点：

* 应用程序的内存布局
* 应用程序发出的系统调用

## 应用程序设计

# 实现特权级的切换

## RISC-V特权级切换

### 特权级切换的起因

Batch OS需要在执行应用程序之前进行一些init工作，并监控应用程序的执行：

* 启动App时，需要初始化App的用户态上下文，并且切换到用户态执行App
* App发起*Syscall*后，需要切换到BatchOS中处理
* App执行*出错*时，BatchOS要杀死该App并加载下一个App
* App执行*结束*时，BatchOS要加载下一个App

特权级的切换需要HardWare和OS协同提供特权级切换机制。

### Priv切换相关的CSR

例子：CPU在U Mode下触发Trap,切换到S Mode的BatchOS进行处理：

| CSR Name | The func about Trap |
| :---: | :---: |
| `sstatus` | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
| `sepc` | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| `scause` | 描述 Trap 的原因 |
| `stval` | 给出 Trap 附加信息 |
| `stvec` | 控制 Trap 处理代码的入口地址 |

## Priv切换的HD控制机制

CPU执行一条指令，并准备从U Mode*陷入（Trap）*到S Mode的时候，硬件会：

* `sstatus`的`SPP`字段会被修改为CPU当前的特权级（U/S）
* `sepc`会被修改为Trap处理完成后，默认会执行的下一个指令的地址
* `scause/stval`分别会修改成这次Trap的原因，以及相关附加信息
* CPU跳转到`stvec`所设置的Trap处理入口函数，并将当前特权级设置为S，然后从Trap处理入口地址处开始执行

> [!NOTE]
> 目前我们只会将`stvec`设置为Direct模式，而`stvec`还可以被设置为Vectored模式

CPU完成Trap处理返回时，需要通过S特权级的特权指令`sret`来完成：

* CPU会将当前特权级按照`sstatus`的`SPP`字段设置为U或者S
* CPU会跳转到`sepc`寄存器指向那条指令，然后继续执行

## 用户栈和内核栈

在正式进入Trap执行之前，我们需要保存原控制流的寄存器状态，一般通过栈来完成。但是我们需要用专门为OS准备的**内核栈**，而不是应用程序运行时用到的**用户栈**。

RISC-V中栈是向下生长的。

Trap 的上下文：

* `x0~x31`
* `sstatus`
* `sepc`

> [!NOTE]
>对于通用寄存器而言，两条控制流（应用程序控制流和内核控制流）运行在不同的特权级，所属的软件也可能由不同的编程语言编写，虽然在 Trap 控制流中只是会执行 Trap 处理 相关的代码，但依然可能直接或间接调用很多模块，因此很难甚至不可能找出哪些寄存器无需保存。既然如此我们就只能全部保存了。但这里也有一些例外， 如 x0 被硬编码为 0 ，它自然不会有变化；还有 tp(x4) 寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到。虽然它们无需保存， 但我们仍然在 TrapContext 中为它们预留空间，主要是为了后续的实现方便。
>
> 对于 CSR 而言，我们知道进入 Trap 的时候，硬件会立即覆盖掉 scause/stval/sstatus/sepc 的全部或是其中一部分。scause/stval 的情况是：它总是在 Trap 处理的第一时间就被使用或者是在其他地方保存下来了，因此它没有被修改并造成不良影响的风险。 而对于 sstatus/sepc 而言，它们会在 Trap 处理的全程有意义（在 Trap 控制流最后 sret 的时候还用到了它们），而且确实会出现 Trap 嵌套的情况使得它们的值被覆盖掉。所以我们需要将它们也一起保存下来，并在 sret 之前恢复原样。

## Trap 管理

## 执行应用程序

当BatchOS init之后，或者某个App运行或出错的时候， 我们调用`run_next_app`函数，切换到下一个应用程序
此时CPU运行在S Mode中，而它希望能切换的到U Mode。在RISC-V架构中，唯一一个能够使CPU Priv**下降**的方法就是通过**Trap返回系列指令**，即`sret`。运行应用程序之前要完成：
> [!NOTE]
>
> * 跳转到应用程序入口点`0x80400000`
> * 将使用的栈切换到用户栈
> * 在`__alltraps`时，我们要求`sscratch`指向内核栈，这个也需要在此时完成
> * 从S Priv转换到U Priv
